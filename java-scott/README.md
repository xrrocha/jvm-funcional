# Scott: Un Ejemplo de DSL Funcional en Java

![tl-dr;](docs/img/tl-dr.png)
Este repositorio ilustra el dise침o, implementaci칩n y uso de un lenguaje de dominio espec칤fico (DSL) en Java 17
empleando patrones funcionales.
El argumento de estudio es una aplicaci칩n SpringBoot JPA inspirada en el tradicional esquema Oracle _scott/tiger_.
Para comprender las t칠cnicas empleadas para implementar este DSL es 칰til tener familiaridad con las 
[lambdas de Java](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 
as칤 como con 
[Spring Data JPA](https://spring.io/projects/spring-data-jpa).

El DSL implementado en este repositorio captura patrones repetitivos en componentes Spring que hacen uso de 
repositorios JPA (`@Service`, `@Controller`, ...).

Un servicio Spring t칤pico implementar칤a imperativamente la persistencia de una nueva instancia de `Departamento` en 
la base de datos como:

```java
// Retorna id generado para nuevo departamento
public String crearDepartamento(String codigo, String nombre, String localidad) {
    // Construye y valida departamento
    final Departamento departamento;
    try {
        departamento = Departamento.builder()
                            .codigo(codigo)
                            .nombre(nombre)
                            .localidad(localidad)
                            .build();
    } catch (Exception e) {
        throw new RuntimeException("Error de validaci칩n creando departamento", e);
    }

    // Persiste nuevo departamento
    final Departamento departamentoGuardado;
    try {
        departamentoGuardado = repositorioDepartamento.save(departamento);
    } catch (Exception e) {
        throw new RuntimeException("Error persistiendo nuevo departamento", e);
    }

    // Retorna id generado para nuevo departamento
    return departamentoGuardado.getId();
}
```

Empleando el DSL implementado en este repositorio, el c칩digo anterior queda reducido a:

```java
// Retorna id generado para nuevo departamento
public String crearDepartamento(String codigo, String nombre, String localidad) {
    return persistirInstancia(
        repositorioDepartamento, Departamento::getId,
        () -> Departamento.builder()
                  .codigo(codigo)
                  .nombre(nombre)
                  .localidad(localidad)
                  .build()
    ));
}
```

### El Modelo de Datos _scott/tiger_

El modelo de datos de ejemplo esta inspirado en el esquema 
[scott/tiger](https://www.orafaq.com/wiki/SCOTT) tradicionalmente empleado por Oracle 
Corporation para ense침ar el lenguaje SQL. 

Adem치s de reformularlo en espa침ol, en este repositorio se le a침ade a este modelo algunos peque침os detalles para 
utilizarlo mediante JPA:

![Modelo](docs/img/modelo.png)

La definici칩n de `Departamento` como entidad JPA mostrada a continuaci칩n hace uso de 
[Lombok](https://www.javatpoint.com/lombok-java) y de 
[Java EE Validation](https://docs.oracle.com/javaee/7/tutorial/bean-validation.htm)
as칤 como del soporte brindado por la superclase 
[Entidad](src/main/java/scott/infra/jpa/entidad/Entidad.java):

```java
@Entity
@Table(name = "departamento", uniqueConstraints = { 
    @UniqueConstraint(name = "dept_uk_codigo", columnNames = {"codigo"})})
@Getter
@ToString(onlyExplicitlyIncluded = true)
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Departamento extends Entidad {
    @ToString.Include
    @NotNull(message = "El c칩digo del departamento debe ser especificado")
    @Pattern(regexp = "^[0-9]{2}$", message = "C칩digo de departamento inv치lido; debe constar de dos d칤gitos")
    @Basic(optional = false)
    @Column(name = "codigo", nullable = false, length = 2)
    private String codigo;

    @ToString.Include
    @NotNull(message = "El nombre del departamento debe ser especificado")
    @Pattern(regexp = "^\\p{IsLatin}{2,16}$", message = "Nombre de departamento inv치lido; solo puede contener letras")
    @Basic(optional = false)
    @Column(name = "nombre", nullable = false, length = 16)
    private String nombre;

    @ToString.Include
    @NotNull(message = "La localidad del departamento debe ser especificada")
    @Pattern(regexp = "^\\p{IsLatin}{2,16}$", message = "Localidad de departamento inv치lida; solo puede contener letras")
    @Basic(optional = false)
    @Column(name = "localidad", nullable = false, length = 16)
    private String localidad;

    @OneToMany(mappedBy = "departamento", cascade = CascadeType.ALL)
    private final Set<Empleado> empleados = new HashSet<>();

    @Builder
    public Departamento(String codigo, String nombre, String localidad) {
        this.codigo = codigo;
        this.nombre = nombre;
        this.localidad = localidad;
        validarAtributos();
    }

    public String relocalizar(String nuevaLocalidad) {
        String anteriorLocalidad = this.localidad;
        this.localidad = nuevaLocalidad;
        validarAtributos();
        return anteriorLocalidad;
    }
}
```
游녤 Este repositorio ilustra tambi칠n otros aspectos de implementaci칩n de JPA que pueden ser de inter칠s para el is 
m치s all치 del DSL. Esto incluye soporte gen칠rico a enumeraciones, generaci칩n de identificadores desde la aplicaci칩n, 
envoltura de repositorios JPA en espa침ol y otros temas m치s...


### Insertando una Nueva Instancia de Entidad (Toma 1)

Para persistir una nueva instancia de `Departamento` se requerir칤a algo como:

```java
public String crearDepartamento(String codigo, String nombre, String localidad) {
    // Construye y valida departamento
    final Departamento departamento;
    try {
        departamento = Departamento.builder()
                .codigo(codigo)
                .nombre(nombre)
                .localidad(localidad)
                .build();
    } catch (Exception e) {
        throw new RuntimeException("Error de validaci칩n creando departamento", e);
    }

    // Persiste nuevo departamento
    final Departamento departamentoGuardado;
    try {
        departamentoGuardado = repositorioDepartamento.save(departamento);
    } catch (Exception e) {
        throw new RuntimeException("Error de persistencia creando departamento", e);
    }

    // Retorna id generado para nuevo departamento
    return departamentoGuardado.getId();
}
```

Para persistir una nueva instancia de `Empleado` se requerir칤a algo _muy semejante_, en el estilo de:

```java
public String crearEmpleado(String codigo, String nombre, Genero genero) {
    // Construye y valida instancia de empleado
    final Empleado empleado;
    try {
        empleado = Empleado.builder()
            .codigo(codigo)
            .nombre(nombre)
            .genero(genero)
            .build();
    } catch (Exception e) {
        throw new RuntimeException("Error de validaci칩n creando empleado", e);
    }

    // Persiste nuevo Empleado
    final Empleado empleadoGuardado;
    try {
        empleadoGuardado = repositorioEmpleado.save(empleado);
    } catch (Exception e) {
        throw new RuntimeException("Error de persistencia creando empleado", e);
    }

    // Retorna id generado para nuevo empleado
    return empleadoGuardado.getId();
}
```

En los dos casos se repite el mismo patr칩n:

- Declarar y poblar una nueva instancia de la entidad, generando una excepci칩n si hay errores de validaci칩n
- Guardar la nueva instancia creando as칤 una nueva versi칩n ya almacenada y generando una excepci칩n si hay errores 
  de persistencia
- Retornar la nueva clave primaria generada por el sistema

Var칤an los detalles, pero el c칩digo (repetitivo y tedioso) tiene siempre la misma estructura!

### Claves Naturales y Sint칠ticas

En el uso de bases de datos relacionales de hoy es frecuente reemplazar las claves primarias "naturales" (tales como 
la _c칠dula_ de la persona o el _c칩digo_ del departamento) por claves primarias "sint칠ticas" generadas por el sistema.

```sql
CREATE TABLE departamento (
    id     INTEGER     NOT NULL DEFAULT nextval('departamento_seq') PRIMARY KEY,
    codigo VARCHAR(16) NOT NULL UNIQUE,
    nombre VARCHAR(24) NOT NULL
);
CREATE TABLE empleado (
    id              VARCHAR(32) NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    codigo          VARCHAR(16) NOT NULL UNIQUE,
    nombre          VARCHAR(24) NOT NULL,
    id_departamento INTEGER     NOT NULL REFERENCES departamento (id),
    id_supervisor   VARCHAR(32) REFERENCES empleado (id)
);
```

Para impedir que se a침adan nuevas instancias con valores duplicados de clave natural:

- Se a침ade una restricci칩n `UNIQUE` en la(s) columna(s) de la clave natural
- Se a침ade una anotaci칩n `@Table/@UniqueConstraint` a la entidad JPA 
- Se verifica en la aplicaci칩n Spring que no exista ya en la tabla una fila con el mismo valor de clave natural

游녤 En nuestro repositorio de ejemplo hemos establecido la simplificaci칩n de que todas las claves primarias sint칠ticas
son de tipo `String` y corresponden a un _random `UUID`_ generado desde la aplicaci칩n.

### Insertando una Nueva Instancia de Entidad (Toma 2)

Para garantizar que no haya m칰ltiples departamentos con el mismo c칩digo, la persistencia de una nueva instancia de 
`Departamento` lucir칤a ahora como:

```java
public String crearDepartamento(String codigo, String nombre, String localidad) {
    // Construye y valida departamento
    final Departamento departamento;
    try {
        departamento = Departamento.builder()
            .codigo(codigo)
            .nombre(nombre)
            .localidad(localidad)
            .build();
    } catch (Exception e) {
        throw new RuntimeException("Error de validaci칩n creando departamento", e);
    }
    
    // *** La nueva validaci칩n de unicidad ocurre aqu칤 ***
    // Valida que el c칩digo de departamento no sea duplicado
    final Optional<Departamento> optDepartamento;
    try {
        optDepartamento = repositorioDepartamento .findByCodigo(codigo);
    } catch (Exception e) {
        throw new RuntimeException("Error recuperando departamento por c칩digo", e);
    }
    optDepartamento.ifPresent(d -> {
        String mensaje = "Ya existe un departamento con codigo %s: %s!".formatted(codigo, d.getNombre());
        throw new IllegalArgumentException(mensaje);
    });
    // *** Fin de nueva validaci칩n de unicidad ***

    // Persiste nuevo departamento
    final Departamento departamentoGuardado;
    try {
        departamentoGuardado = repositorioDepartamento.save(departamento);
    } catch (Exception e) {
        throw new RuntimeException("Error de persistencia creando departamento", e);
    }

    // Retorna id generado para nuevo departamento
    return departamentoGuardado.getId();
}
```

La creaci칩n de una nueva entidad de `Empleado` se ver치 tambi칠n aumentada con una verificaci칩n adicional equivalente.

Esto es repetitivo, tedioso y _propenso al error_!

游녤 **Una de las principales fuentes de _bugs_ en el desarrollo de aplicaciones son los errores en la transcripci칩n de 
recetas repetitivas como esta**.

### Capturando Recetas Repetitivas

Qu칠 es lo que cambia de entidad en entidad cuando queremos persistir una nueva instancia en la base de datos?

- Cambia el tipo de datos concreto de la entidad (`Departamento`, `Empleado`, ...)
- Cambia la l칩gica que construye y valida una nueva instancia de la entidad en memoria
- Cambia la l칩gica que valida la instancia antes de persistirla (por ejemplo para validar unicidad de clave natural)

Todo lo dem치s tiene _siempre_ la misma l칩gica!

Para formular las partes m칩viles de forma reutilizable Java provee dos poderosos mecanismos: 

- Tipos de datos gen칠ricos y 
- Lambdas

Para las clases de entidad se puede definir un tipo gen칠rico `E`.

La porci칩n de l칩gica que construye en memoria una nueva instancia de entidad es una lambda de tipo `Supplier<E>`.

La porci칩n de l칩gica que valida la nueva instancia de entidad en memoria antes de persistirla ser칤a un `Consumer<E>` 
opcional que puede fallar con una excepci칩n.

Veamos:

```java
public static<E, I> I persistirInstancia(
    JpaRepository<E, I>   repositorio,
    Function<E, I>        clavePrimaria,
    Consumer<E>           validacion,
    Supplier<E>           crearInstancia
) {
    final E entidad;
    try {
        entidad = crearInstancia.get();
    } catch(Exception e) {
        throw new ExcepcionDSL("Error creando instancia de entidad en memoria",e);
    }

    if (validacion != null) {
        try {
            validacion.accept(entidad);
        } catch(Exception e) {
            throw new ExcepcionDSL("Error de validaci칩n de entidad",e);
        }
    }

    final E entidadGuardada;
    try {
        entidadGuardada = repositorio.save(entidad);
    } catch(Exception e) {
        throw new ExcepcionDSL("Error persistiendo nueva instancia",e);
    }

    return clavePrimaria.apply(entidadGuardada);
}

// Este m칠todo sintetiza y retorna una nueva funci칩n (high-order)
public static <E, C> Consumer<E> detectarDuplicado(Function<C, Optional<E>> extractor, C valorClave) {
    return e -> extractor.apply(valorClave).ifPresent(t -> {
        throw new ExcepcionDSL("Ya existe una instancia con la misma clave: %s".formatted(valorClave));
    });
}
```

Armados con estos m칠todo gen칠rico, la creaci칩n de un nuevo departamento lucir칤a como:

```java
public String crearDepartamento(String codigo, String nombre, String localidad) {
    return persistirInstancia(
        repositorioDepartamento,
        detectarDuplicado(repositorioDepartamento::buscarPorCodigo, codigo),
        () -> Departamento.builder()
                .codigo(codigo)
                .nombre(nombre)
                .localidad(localidad)
                .build()
    ));
}
```

游뱔 Aah, _excelente_ simplificaci칩n! 

Y es segura en tipos de datos! Si, por error, escribi칠ramos `repositorioEmpleado` donde debiera decir 
`repositorioDepartamento`, el compilador de Java y/o la IDE detectar칤an la discrepancia y se quejar칤an _de inmediato_.

### Reflexiones Acerca del Estilo del DSL

Como es natural, nuestro m칠todo DSL es, en su forma inicial, imperfecto:

- No soluciona _todos_ nuestros problemas
- Nos trae _nuevos_ problemas causados por 칠l mismo

Qu칠 problemas nuevos nos trae? 

Uno inmediatamente evidente es que los mensajes de error son demasiado gen칠ricos y no proveen contexto. Donde 
nuestra versi칩n original sol칤a decir `Ya existe un departamento con codigo 30: Ventas!` ahora nuestro m칠todo DSL 
reporta un cr칤ptico `Ya existe una instancia con la misma clave: 30`. Claramente, esto podr칤a 
mejorar!

Qu칠 problemas no soluciona?

Un problema con nuestro c칩digo original es que hace uso muy liberal de las excepciones. Ser칤a deseable que nuestro 
DSL nos liberara de tener que lidiar continuamente con las excepciones, pero tambi칠n que nos permitiera ocuparnos 
apropiadamente de ellas cuando as칤 se requiera.

游녤 Algunos programadores Java no ver칤an en esto un problema. Despu칠s de todo, las excepciones son el mecanismo est치ndar 
del lenguaje para reportar o propagar condiciones de error. Sin embargo, las excepciones rompen el control de flujo
y, tomadas a la ligera, dificultan lidiar con las condiciones de error. En la pr치ctica, muchos desarrolladores 
simplemente ignoran las excepciones y las dejan propagar hasta el nivel superior de la aplicaci칩n! 
_Somewhere in the Rytridian Galaxy, Ultra Lord weeps 游봌_

### El Tipo de Datos `Either` al Rescate!

La programaci칩n funcional ofrece tambi칠n una manera de ocuparse de las condiciones de error _como datos_ y no como una 
ruptura del flujo natural del programa: el tipo de datos `Either`

La librer칤a funcional [Vavr](https://vavr.io) provee una implementaci칩n conveniente del tipo de datos funcional 
`Either<L, R>` para Java. 

Una instancia de `Either<L, R>` contiene uno de dos posibles valores:

- Un valor 칰til (`R`, por _right_) si la computaci칩n que le di칩 origen complet칩 exitosamente, o
- Un valor de error (`L`, por _left_) si la computaci칩n termin칩 anormalmente

游녤 Que el valor exitoso de `Either` est칠 a la derecha y no a la izquierda puede resultar contra-intuitivo a algunos
pero es, simplemente, una convenci칩n (originalmente establecida por el lenguaje Haskell).

Lo interesante del uso de este tipo de datos es que, cuando todos los m칠todos coinciden en retornar `Either`, es 
posible encadenarlos en _pipelines_ de transformaci칩n que parecer칤an no tener que ocuparse de posibles errores!
Esto produce c칩digo muy legible con apariencia de _happy path_.

C칩mo? Primero necesitamos una forma de convertir lambdas que generan excepciones en instancias de `Either`.

Es f치cil convertir una lambda que retorna `T` (y que puede fallar) en un `Either<RuntimeException, T>` tal que la
excepci칩n retornada en el lado izquierdo contenga un mensaje apropiado para el contexto de ejecuci칩n:

```java
public static <T> 
Either<RuntimeException, T> eitherCatch(String contexto, CheckedFunction0<T> lambda) {
    try {
        return Either.right(lambda.apply());
    } catch (Throwable t) {
        return Either.left(new RuntimeException("Error: " + contexto, t));
    }
}
```

Dado este m칠todo de conversi칩n, la l칩gica de persistencia de una nueva entidad se simplificar칤a como:

```java
public static <E, I> Either<Falla, I> persistirInstancia(
    JpaRepository<E, I>     repositorio,
    CheckedFunction1<E, I>  clavePrimaria,
    CheckedConsumer<E>      validacion,
    CheckedFunction0<E>     crearInstancia
) {
    return eitherCatch("creando instancia de entidad en memoria", crearInstancia)
        .flatMap(entidad ->
            eitherCatch("validando instancia de entidad en memoria", entidad, validacion))
        .flatMap(entidad ->
            eitherCatch("persistiendo nueva instancia", () -> repositorio.save(entidad)))
        .flatMap(entidad ->
            eitherCatch("recuperando clave primaria", () -> clavePrimaria.apply(entidad)));
}
```

Esta implementaci칩n del m칠todo DSL es mucho m치s simple e inteligible que la versi칩n basada en excepciones!

Cuando `Either` falla, la l칤nea de transformaci칩n se interrumpe inmediatamente! Por esta raz칩n se dice que el lado 
izquierdo de `Either` causa un _cortocircuito_.

Esta es la raz칩n por la que es posible concatenar las acciones sin (aparentemente) ocuparse de los errores. En el 
c칩digo anterior, el texto descriptivo de cada paso de la l칤nea de transformaci칩n se utiliza como contexto para 
generar el mensaje de error apropiado para toda posible excepci칩n.

Al final, el nivel superior de la aplicaci칩n decide qu칠 hacer cuando hay errores: hacer _logging_, retornar un 
c칩digo HTTP 404, etc.

Para apreciar el uso de patrones funcionales en un DSL Java v칠ase el
[DSL de repositorios JPA](src/main/java/scott/infra/jpa/RepositorioDSL.java).

Para apreciar el uso del DSL en c칩digo "real" v칠ase:

- [El servicio de departamento](src/main/java/scott/dominio/ServicioDepartamento.java)
- [El servicio de empleado](src/main/java/scott/dominio/ServicioEmpleado.java)
- [La prueba de integraci칩n de estos servicios](src/test/java/scott/dominio/EscenarioIT.java)
